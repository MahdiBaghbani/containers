# SPDX-License-Identifier: AGPL-3.0-or-later
# Reusable workflow for building a single service (all versions)
# Called by build.yml for per-service orchestration with cache-based image reuse

name: Build Service

on:
  workflow_call:
    inputs:
      service:
        description: "Service name to build"
        required: true
        type: string
      push:
        description: "Push images to registry (not used in build-only workflow)"
        required: false
        type: boolean
        default: false

jobs:
  build-service:
    name: Build ${{ inputs.service }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nushell
        env:
          NU_VERSION: "0.108.0"
        run: |
          curl -fsSL -o /tmp/nu.tar.gz \
            "https://github.com/nushell/nushell/releases/download/${NU_VERSION}/nu-${NU_VERSION}-x86_64-unknown-linux-gnu.tar.gz"
          mkdir -p /tmp/nu
          tar -xzf /tmp/nu.tar.gz -C /tmp/nu --strip-components=1
          sudo mv /tmp/nu/nu /usr/local/bin/nu
          nu --version

      - name: Install zstd
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y zstd

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker

      # Cache restore with commit+branch keys for precise reuse
      # Each commit gets its own cache key; cross-commit reuse via prefix restore
      # Uses directory-based cache with per-image-ID .tar.zst files
      - name: Restore Docker image cache
        id: cache-restore
        uses: actions/cache/restore@v4
        with:
          path: /tmp/docker-images/${{ inputs.service }}/
          key: images-${{ inputs.service }}-${{ github.ref }}-${{ github.sha }}
          restore-keys: |
            images-${{ inputs.service }}-${{ github.ref }}-

      # Compute cache match kind for diagnostics
      # exact: cache key matched exactly (same commit)
      # fallback: cache restored from older commit on same branch
      # miss: no cache found
      - name: Determine cache match kind
        id: cache-match
        run: |
          PRIMARY_KEY="images-${{ inputs.service }}-${{ github.ref }}-${{ github.sha }}"
          MATCHED_KEY="${{ steps.cache-restore.outputs.cache-matched-key }}"
          CACHE_HIT="${{ steps.cache-restore.outputs.cache-hit }}"
          
          if [ "$CACHE_HIT" = "true" ]; then
            if [ "$MATCHED_KEY" = "$PRIMARY_KEY" ]; then
              MATCH_KIND="exact"
            else
              MATCH_KIND="fallback"
            fi
          else
            MATCH_KIND="miss"
          fi
          
          echo "Cache match kind: $MATCH_KIND"
          echo "  Primary key: $PRIMARY_KEY"
          echo "  Matched key: $MATCHED_KEY"
          echo "match_kind=$MATCH_KIND" >> $GITHUB_OUTPUT

      - name: Load cached images
        if: steps.cache-restore.outputs.cache-hit == 'true'
        run: |
          if [ -d "/tmp/docker-images/${{ inputs.service }}" ]; then
            echo "Loading cached images for ${{ inputs.service }}..."
            nu scripts/ci-load-owner-tarballs.nu --service ${{ inputs.service }}
            echo "Cache load complete"
          else
            echo "Cache directory not found, will build from scratch"
          fi

      # Build the service with dep-cache=soft for hash-based dependency reuse
      - name: Show build order
        run: |
          echo "Build order for ${{ inputs.service }}:"
          nu scripts/build.nu --service ${{ inputs.service }} --all-versions --show-build-order

      - name: Build service
        run: |
          echo "Cache match kind: ${{ steps.cache-match.outputs.match_kind }}"
          nu scripts/build.nu \
            --service ${{ inputs.service }} \
            --all-versions \
            --dep-cache=soft \
            --pull=deps,externals \
            --cache-match=${{ steps.cache-match.outputs.match_kind }}

      # Save images using SHA-deduplicated tarballs
      - name: Save images to cache
        if: success()
        run: |
          echo "Saving image tarballs for ${{ inputs.service }}..."
          nu scripts/ci-save-owner-tarballs.nu --service ${{ inputs.service }}
          echo "Cache directory contents:"
          ls -lh /tmp/docker-images/${{ inputs.service }}/ || echo "No tarballs saved"

      - name: Save Docker image cache
        if: success()
        uses: actions/cache/save@v4
        with:
          path: /tmp/docker-images/${{ inputs.service }}/
          key: images-${{ inputs.service }}-${{ github.ref }}-${{ github.sha }}
